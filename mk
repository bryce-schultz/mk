#!/usr/bin/env python3

import os
import sys
import re
import argparse

version = '1.5'
description = f'Makefile generator and runner'

isatty = os.isatty(sys.stdout.fileno())
yellow = '\033[93m' if isatty else ''
red = '\033[91m' if isatty else ''
green = '\033[92m' if isatty else ''
reset = '\033[0m' if isatty else ''

class Target:
    def __init__(self, file, path='.'):
        self.file = file
        self.path = path
        self.iscpp = file.endswith('.cpp')
        self.isc = file.endswith('.c')
        self.name = file.rsplit('.', 1)[0]
        self.deps = []
        self._find_deps(file)

    def _find_deps(self, file):
        cmd_result = run_cmd(f'g++ -MM {file}')
        cmd_result = cmd_result.replace('\\', '')
        cmd_result = cmd_result.replace('\n', '')
        # parse the result
        dep_files = cmd_result.split()[1:]
        header_files = [f for f in dep_files if f.endswith('.h') or f.endswith('.hpp')]
        cpp_source_files = [f for f in dep_files if f.endswith('.cpp')]
        c_source_files = [f for f in dep_files if f.endswith('.c')]
        all_source_files = cpp_source_files + c_source_files
        self.deps += [f.rsplit('.', 1)[0] + '.o' for f in all_source_files]

        all_cpp_files = []
        all_c_files = []
        for root, _, files in os.walk(self.path):
            all_cpp_files.extend([os.path.join(root, f).lstrip('./') for f in files if f.endswith('.cpp')])
            all_c_files.extend([os.path.join(root, f).lstrip('./') for f in files if f.endswith('.c')])

        # check if the header files have corresponding source files
        for header in header_files:
            header_name = header.rsplit('.', 1)[0]
            header_as_cpp = header_name + '.cpp'
            header_as_c = header_name + '.c'
            header_as_obj = header_name + '.o'
            if header_as_obj in self.deps:
                    continue
            elif header_as_cpp in all_cpp_files:
                self._find_deps(header_as_cpp)
            elif header_as_c in all_c_files:
                self._find_deps(header_as_c)

    def __str__(self):
        return f'{" ".join(self.deps)}'

    def __repr__(self):
        return f'{self.name}: {" ".join(self.deps)}'

def find_all_targets(path):
    files = [f for f in os.listdir(path) if f.endswith('.cpp') or f.endswith('.c')]
    targets = []
    for file in files:
        with open(f'{path}/{file}', 'r') as f:
            content = f.read()
            if re.search(r'\bmain\b', content):
                targets.append(Target(file, path))
    return targets

def run_cmd(cmd, show_output=False):
    import subprocess
    if show_output:
        result = subprocess.run(cmd, shell=True)
    else:
        try:
            result = subprocess.run(cmd, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        except subprocess.CalledProcessError as e:
            print(f'{red}error{reset}: {e.stderr.decode()}')
            return None
        return result.stdout.decode()

def get_deps(path):
    # check if the path contains .c files
    cfiles = [f for f in os.listdir(path) if f.endswith('.c')]
    cppfiles = [f for f in os.listdir(path) if f.endswith('.cpp')]

    cmd = 'g++ -MM ' + ' '.join(cfiles + cppfiles)

    deps = run_cmd(cmd)

    return deps

def find_target(path, files):
    for f in files:
        with open(f'{path}/{f}', 'r') as file:
            content = file.read()
            if re.search(r'\bmain\b', content):
                # remove the file extension
                return f.rsplit('.', 1)[0]
    return None

def write_header(makefile, targets):
    makefile.write(f'# Makefile auto generated by mk {version}\n#\n')
    makefile.write(f'# Targets:\n')
    for target in targets:
        makefile.write(f'# - {target.name}\n')
    makefile.write('\n')

def write_compiler_options(makefile):
    makefile.write(f'# Compiler Options:\n')
    makefile.write(f'CXXC = g++\n')                                     # default cpp compiler
    makefile.write(f'CC = gcc\n')                                       # default c compiler
    makefile.write(f'CXXFLAGS = -Wall -Wextra -pedantic\n')             # default cpp flags
    makefile.write(f'CFLAGS = -Wall -Wextra -pedantic\n')               # default cpp standard
    makefile.write(f'LDFLAGS = -lm\n\n')                                # default linker flags

def write_target_executables(makefile, targets):
    makefile.write(f'# Target Executables:\n')
    for target in targets:
        target_name_all_caps = target.name.upper()
        makefile.write(f'{target_name_all_caps}_EXE = {target.name}\n') # target name
    makefile.write('\n')

def write_object_files(makefile, targets):
        makefile.write(f'# Object Files:\n')
        for target in targets:
            target_name_all_caps = target.name.upper()
            makefile.write(f'{target_name_all_caps}_OBJS = {" \\\n ".join(target.deps)}\n')
        makefile.write('\n')  

def write_phony_targets(makefile):
    makefile.write(f'# Phony Targets:\n')
    makefile.write(f'.PHONY: all clean\n\n')                            # phony targets

def write_all_targets(makefile, targets):
    makefile.write(f'# All Targets:\n')
    makefile.write('all: ')
    target_names = [f"$({t.name.upper()}_EXE)" for t in targets]
    makefile.write(' \\\n '.join(target_names) + '\n\n')                # default target

def write_targets(makefile, targets):
    makefile.write(f'# Targets:\n')
    for target in targets:
        target_name_all_caps = target.name.upper()
        exec_name = f'$({target_name_all_caps}_EXE)'
        makefile.write(f'{exec_name}: $({target_name_all_caps}_OBJS)\n')
        if target.iscpp:
            makefile.write(f'\t$(CXXC) $(CXXFLAGS) $({target_name_all_caps}_OBJS) -o {exec_name} $(LDFLAGS)\n')
        else:
            makefile.write(f'\t$(CC) $(CFLAGS) $({target_name_all_caps}_OBJS) -o {exec_name} $(LDFLAGS)\n')
    makefile.write('\n')

def write_clean(makefile, targets):
    makefile.write(f'# Clean:\n')
    makefile.write(f'clean:\n')
    for target in targets:
        target_name_all_caps = target.name.upper()
        makefile.write(f'\trm -f $({target_name_all_caps}_EXE) $({target_name_all_caps}_OBJS)\n')
    makefile.write('\n')

def write_rules(makefile):
    makefile.write(f'# Rules:\n')
    makefile.write(f'.cpp.o:\n')                                        # rules for .cpp files
    makefile.write(f'\t$(CXXC) $(CXXFLAGS) -c $< -o $@\n')
    makefile.write(f'.c.o:\n')                                          # rules for .c files
    makefile.write(f'\t$(CC) $(CFLAGS) -c $< -o $@\n\n')

def write_dependencies(makefile, deps):
    makefile.write(f'# Dependencies:\n')
    makefile.write(deps)                                                # dependencies
    makefile.write('\n')

def write_options(makefile, options):
    if (options == ''):
        return
    makefile.write(f'# Options from .mk file:\n')
    makefile.write(options)
    makefile.write('\n')

def read_options(path):
    # read the .mk file and copy its contents into the makefile here:
        # check for new line at the end and add one if it doesn't exist
        with open(f'{path}/.mk', 'r') as mkfile:
            mkfile_contents = mkfile.read()
            if (len(mkfile_contents) != 0):
                if mkfile_contents[-1] != '\n':
                    mkfile_contents += '\n'
            return mkfile_contents

def generate_makefile(path, args):
    # find the target
    targets = find_all_targets(path)
    if len(targets) == 0:
        print(f'{red}error{reset}: No target found in {path}')
        sys.exit(1)

    # write the Makefile
    with open(f'{path}/Makefile', 'w') as makefile:
        # Header
        write_header(makefile, targets)

        # Compiler Options
        write_compiler_options(makefile)

        # Target Executables
        write_target_executables(makefile, targets)

        # Object Files
        write_object_files(makefile, targets)

        # Phony Targets
        write_phony_targets(makefile)

        # All Targets
        write_all_targets(makefile, targets)

        # Targets
        write_targets(makefile, targets)

        # Clean
        write_clean(makefile, targets)

        # Rules
        write_rules(makefile)

        # Dependencies
        write_dependencies(makefile, get_deps(path))

        # Options from .mk file
        write_options(makefile, read_options(path))

        print('-> Makefile')

def run_make(make_args):
    cmd = 'make ' + ' '.join(make_args)
    run_cmd(cmd, show_output=True)

def print_overwrite_warning(path):
    if (path == '.'):
        print(f'{yellow}warning{reset}: this will overwrite the Makefile in the current directory')
    else:
        print(f'{yellow}warning{reset}: this will overwrite the Makefile in {path}')

def build_make_args(args):
    make_args = []
    if args.jobs:
        make_args.append(f'-j {args.jobs}')
    if args.always_make:
        make_args.append('-B')
    if args.clean:
        make_args.append('clean')
    return make_args

def prompt_overwrite(path):
    print_overwrite_warning(path)
    answer = input('Do you want to overwrite it? (y/n): ')
    if answer.lower() != 'y':
        return False
    return True

def check_makefile_override(path):
    if os.path.exists(f'{path}/Makefile') and not os.path.exists(f'{path}/.mk'):
        return prompt_overwrite(path)
    return True
    
def main(args):
    path = args.path
    if not os.path.exists(path):
        print(f'{red}error{reset}: path {path} does not exist')
        sys.exit(1)

    if not check_makefile_override(path):
        sys.exit(0)

    if not os.path.exists(f'{path}/.mk'):
        # create .mk file
        with open(f'{path}/.mk', 'w') as mkfile:
            mkfile.close()

    generate_makefile(path, args)

    if args.run:
        make_args = build_make_args(args)
        run_make(make_args)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=f'{description} {version}')
    parser.add_argument('path', nargs='?', default='.')
    parser.add_argument('-j', '--jobs', type=int, help='number of jobs to run simultaneously')
    parser.add_argument('-B', '--always-make', action='store_true', help='unconditionally make all targets')
    parser.add_argument('-v', '--version', action='version', version=version)
    parser.add_argument('-c', '--clean', action='store_true', help='clean the directory')
    parser.add_argument('-r', '--run', action='store_true', help='run the make command')
    main(parser.parse_args())
